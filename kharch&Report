<div class="card">
                   <div class="card-header card-header-danger">
                      <h4 class="card-title">Expenses Details :-</h4>
                   </div>
                   <div class="card-body">
                      <div class="row">
                         <div class="col-md-4">
                            <label for="start-date">Start Date:</label>
                            <input type="date" id="start-date" [(ngModel)]="startDateJb" class="form-control" required />
                         </div>
                         <div class="col-md-4">
                            <label for="end-date">End Date:</label>
                            <input type="date" id="end-date" [(ngModel)]="endDateJb" class="form-control" required />
                         </div>
                      </div>
                      <div class="row" *ngIf="startDateJb && endDateJb">
                        <div class="col-md-8">
                            <mat-form-field appearance="fill" style="width: 100%;">
                              <mat-label>Select Expense</mat-label>
                              <mat-select placeholder="Select Expense"
                                          [(ngModel)]="selectedExpense"
                                          (selectionChange)="expensesExcel($event)">
                                <mat-option *ngFor="let expense of expensesList" [value]="expense">
                                  {{ expense }}
                                </mat-option>
                              </mat-select>
                            </mat-form-field>
                          </div>
                          
                      </div>
                   </div>
                </div>
				
				expensesExcel(event: any): void {
    const dialogRef = this.dialog.open(ExpensesExcelComponent, {
      width: "50%",
      height: "50%",
      data: {
        expense: this.selectedExpense,
        startDate: this.startDateJb,
        endDate: this.endDateJb,
      },
    });
    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        location.reload();
      }
    });
  }
  
  
  export class ExpensesExcelComponent implements OnInit {

  isReload: boolean;
  expenseList: any[] = [];
  
  constructor(@Inject(MAT_DIALOG_DATA) public data: any,
    private user: UserServiceService, private dialogRef: MatDialogRef<ExpensesExcelComponent>) {
  }

  ngOnInit(): void {
    this.fetchExpence();
  }

  fetchExpence(): void {
    this.user.getExpenses(this.data.expense, this.data.startDate, this.data.endDate).subscribe((data: any[]) => {
    this.expenseList = data.map(item => ({
      date: item.date,
      expenses: item.expenses,
      price: item.price
    }));
    });

  }


  printTable() {
    const printContent = document.getElementById('ExpenseTable')?.outerHTML;
    const originalContent = document.body.innerHTML;

    document.body.innerHTML = printContent ?? '';
    window.print();
    document.body.innerHTML = originalContent;
    window.location.reload(); // To reload the page and reset the original content
  }

  exportToExcel() {
    // Convert HTML table to workbook
    const ws: XLSX.WorkSheet = XLSX.utils.table_to_sheet(document.getElementById('ExpenseTable')!);
    const wb: XLSX.WorkBook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');

    // Save the workbook
    XLSX.writeFile(wb, 'Expense_Data.xlsx');
  }

  cancel() {
    this.dialogRef.close({ 'isReload': this.isReload });
  }

}



<div class="button-group">
    <button mat-raised-button  (click)="exportToExcel()">
      <mat-icon>file_download</mat-icon>
      Export to Excel
    </button>
    <button mat-raised-button  (click)="printTable()">
      <mat-icon>picture_as_pdf</mat-icon>
      PDF
    </button>
    <button mat-raised-button  (click)="cancel()">
      <mat-icon>cancel</mat-icon>
      Cancel
    </button>
  </div>

<p>Expense Name : -{{data.expense}}</p>
<table id="ExpenseTable">
    <thead>
      <tr>
        <th scope="col">Date</th>
        <th scope="col">Expense</th>
        <th scope="col">Total</th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let item of expenseList">
        <td>{{ item.date }}</td>
        <td>{{ item.expenses }}</td>
        <td>{{ item.price }}</td>
      </tr>
    </tbody>
  </table>
  
  
  
  .button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-bottom: 15px;
  }
  
  .button-group button {
    width: 140px;
  }
  

table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 16px;
    text-align: left;
}

th, td {
    padding: 12px 15px;
    border: 1px solid #ddd;
}

th {
    background-color: #f4f4f4;
    font-weight: bold;
}

tr:nth-child(even) {
    background-color: #f9f9f9;
}

tr:hover {
    background-color: #f1f1f1;
}

strong {
    font-weight: bold;
}

td[colspan="2"] {
    text-align: center;
}

table tr:last-child td {
    border-bottom: 2px solid #ddd;
}

.table-header {
    background-color: #4CAF50;
    color: white;
}

.total-row {
    background-color: #f2f2f2;
    font-weight: bold;
}

.total-amount-row {
    background-color: #e2e2e2;
    font-weight: bold;
}


getExpenses(
    expense: string,
    startDate: string,
    endDate: string
  ): Observable<any[]> {
    const userId = localStorage.getItem("userId");
    let params = new HttpParams()
      .set("expense", expense)
      .set("startDate", startDate)
      .set("endDate", endDate)
      .set("userId", userId);

    return this.http.get<any[]>(API_EXPENSE_EXCEL, { params });
  }
  
  export const API_EXPENSE_EXCEL: string = `${prefix}/portal/api/expensesExcel`;
  
  
   @GetMapping("/expensesExcel")
    public List<kharch> getExpenses(
            @RequestParam("startDate") String startDate,
            @RequestParam("endDate") String endDate,
            @RequestParam("expense") String expense,
            @RequestParam("userId") String userId) {
        return kharchrepository.findByDateBetweenAndExpensesLikeAndUserId(startDate, endDate, expense, userId);
    }
	
	  @Query("SELECT j FROM kharch j WHERE j.date BETWEEN :startDate AND :endDate AND j.expenses LIKE :expenses AND j.userId = :userId")
    List<kharch> findByDateBetweenAndExpensesLikeAndUserId(
            @Param("startDate") String startDate,
            @Param("endDate") String endDate,
            @Param("expenses") String expense,
            @Param("userId") String userId
    );
	
	
	
	
	////////////////////////////////////////////////////
	getTotalPetrolSell(): number {
    return this.PetrolSelltList.reduce((total, product) => 
      total + (parseFloat(product.total_sell) || 0), 0
    );
  }
  
  <td style="background-color: #d0b6b6;"><strong>{{ getTotalDiesel() | number:'1.2-2' }}</strong></td>
   getTotalDiesel(): number {
      return this.DieselSelltList.reduce((sum, product) => 
        sum + (parseFloat(product.total_sell) || 0), 0
      );
  }
  
  
    getTotalOilSell(): number {
      return this.OilsellList.reduce((total, product) => 
        total + (parseFloat(product.price) || 0), 0
      );
  }
  
  getKharch(): number {
      return this.kharchlist.reduce((total, product) => 
        total + (parseFloat(product.price) || 0), 0
      );
  }
  
   getTransaction(): number {
      return this.transaction.reduce((total, product) => 
        total + (parseFloat(product.amount) || 0), 0
      );
  }
  
  //////////////////////////////////////////////////////////////////////////////
   <div class="card">
               <div>
                  <canvasjs-chart [options]="chartOptions2" [styles]="{width: '100%', height:'360px'}"></canvasjs-chart>    
              </div>                        
            </div>
			
			chartOptions2: any = {
    animationEnabled: true,
    title: {
      text: "Fuel & Baki Distribution"
    },
    data: [{
      type: "pie",
      startAngle: 240,
      // yValueFormatString: "##0.00\"%\"",
      indexLabel: "{label} - {y}%",
      dataPoints: []
    }]
  };
  
  updatePieChart() {
    this.chartOptions2 = {
      ...this.chartOptions2,
      data: [{
        type: "pie",
        startAngle: 240,
        // yValueFormatString: "##0.00\"%\"",
        indexLabel: "{label} - {y}",
        dataPoints: [
          { y: this.petrollabel, label: "Petrol ($)" },
          { y: this.diesellabel, label: "Diesel ($)" },
          { y: this.jamabakilabel, label: "Baki ($)" }
        ]
      }]
    };
  }
  CanvasJSAngularChartsModule
  import { CanvasJSAngularChartsModule } from '@canvasjs/angular-charts';
  
  
  
getPurchaselist(){
  const formattedDate = this.use.getFormattedDate(this.reportDate);
  this.use.getPurchaseiList(formattedDate, this.userId).subscribe(
    (data) => {
      if (data && data.length > 0) {
        for (const item of data) {
          const [quantity, type] = item;
          if (type === 'Petrol') {
            this.petolQuantity = quantity;
          } else if (type === 'Diesel') {
            this.dieselQuantity = quantity;
          }
        }
      } else {
        this.petolQuantity = 0;
        this.dieselQuantity = 0;
      }      
    },
    (error) => {
      this.notificationService.failure("Failed to fetch Purchase data.");
    }
  );
}

    @Query("SELECT t1.Quantity,t1.type FROM Purchase t1 WHERE t1.date = :date AND t1.userId = :userId")
    List<Purchase> getPurchase(@Param("date") String date, @Param("userId") String userId);
/////////////////////////

  deleteUser(id) {
     this.use.deleteUser(id).subscribe((result) => {
      this.userList = result;
      this.notificationService.success('User deleted successfully');
      this.getdata();
    });
  }
  
  deleteUser(id: string): Observable<any> {
    return this.http.delete(`${API_USER_DELETE}/${id}`);
  }
  
  export const API_USER_DELETE: string = `${prefix}/portal/api/deleteUser`;
  
  @DeleteMapping("/deleteUser/{id}")
    public ResponseEntity<ApiResponse> deleteUser(@PathVariable Long id) {
        try {
            userRepository.deleteById(id);
            ApiResponse response = new ApiResponse("User deleted successfully");
            return ResponseEntity.ok(response);
        } catch (EmptyResultDataAccessException ex) {
            return ResponseEntity.notFound().build(); 
        }
    }
	
void deleteById(Long id);


//Sidebar
ngOnInit() {
    const userId = localStorage.getItem('userId');
    this.role = localStorage.getItem('role') || '';
  
    this.userService.getUserPump(userId).subscribe(response => {
      const data = response?.data || {};
  
      const xpPetrolEnabled = data?.xp_petrol_nozzle !== '0';
      const powerDieselEnabled = data?.powe_diesel_nozzle !== '0';
  
      // ✅ Step 1: Apply nozzle conditions
      let filteredRoutes = ROUTES.filter(item => {
        if (item.path === '/XPpetrol' && !xpPetrolEnabled) return false;
        if (item.path === '/powerDiesel' && !powerDieselEnabled) return false;
        if ((item.path === '/extraDipp' || item.path === '/extraPurchasedetails') &&
            !xpPetrolEnabled && !powerDieselEnabled) return false;
        return true;
      });
  
      // ✅ Step 2: Apply role-based filter *on top of* nozzle filter
      if (this.role === 'admin') {
        this.menuItems = filteredRoutes.filter(item => item.path === '/User');
      } else if (this.role === 'user') {
        this.menuItems = filteredRoutes.filter(item => item.path !== '/User');
      } else {
        this.menuItems = filteredRoutes;
      }
  
      // ✅ Step 3: Initialize scrollbar
      if (window.matchMedia(`(min-width: 960px)`).matches && !this.isMac()) {
        const elemSidebar = <HTMLElement>document.querySelector('.sidebar .sidebar-wrapper');
        this.ps = new PerfectScrollbar(elemSidebar);
      }
    });
  }
  
  
  //server
  @SpringBootApplication
@EnableAutoConfiguration
@EnableScheduling
public class PumpManagmentApplication extends SpringBootServletInitializer {

    public static void main(String[] args) {
        SpringApplication.run(PumpManagmentApplication.class, args);
    }

}
package pumpManagment.sedular;

import java.text.ParseException;
import java.time.LocalDateTime;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

/**
 *
 * @author Arpitsinh Chauhan
 */
@Service
public class DailyTotalCleanup {

    // Runs every 1 minute
     @Autowired
    private JdbcTemplate jdbcTemplate;

    // Scheduled to run every 1 minute
    @Scheduled(cron = "0 * * * * *", zone = "Asia/Kolkata")
    public void DailyTotalCleanup() {
        String sql = "DELETE FROM dailytotal " +
                 "WHERE (date, user_id) NOT IN ( " +
                 "SELECT DISTINCT date, user_id FROM petrolsell " +
                 "UNION " +
                 "SELECT DISTINCT date, user_id FROM xppetrol " +
                 "UNION " +
                 "SELECT DISTINCT date, user_id FROM dieselsell " +
                 "UNION " +
                 "SELECT DISTINCT date, user_id FROM powerdiesel " +
                 ")";
         int rowsDeleted = jdbcTemplate.update(sql);
    }
}
