<div class="card">
                   <div class="card-header card-header-danger">
                      <h4 class="card-title">Expenses Details :-</h4>
                   </div>
                   <div class="card-body">
                      <div class="row">
                         <div class="col-md-4">
                            <label for="start-date">Start Date:</label>
                            <input type="date" id="start-date" [(ngModel)]="startDateJb" class="form-control" required />
                         </div>
                         <div class="col-md-4">
                            <label for="end-date">End Date:</label>
                            <input type="date" id="end-date" [(ngModel)]="endDateJb" class="form-control" required />
                         </div>
                      </div>
                      <div class="row" *ngIf="startDateJb && endDateJb">
                        <div class="col-md-8">
                            <mat-form-field appearance="fill" style="width: 100%;">
                              <mat-label>Select Expense</mat-label>
                              <mat-select placeholder="Select Expense"
                                          [(ngModel)]="selectedExpense"
                                          (selectionChange)="expensesExcel($event)">
                                <mat-option *ngFor="let expense of expensesList" [value]="expense">
                                  {{ expense }}
                                </mat-option>
                              </mat-select>
                            </mat-form-field>
                          </div>
                          
                      </div>
                   </div>
                </div>
				
				expensesExcel(event: any): void {
    const dialogRef = this.dialog.open(ExpensesExcelComponent, {
      width: "50%",
      height: "50%",
      data: {
        expense: this.selectedExpense,
        startDate: this.startDateJb,
        endDate: this.endDateJb,
      },
    });
    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        location.reload();
      }
    });
  }
  
  
  export class ExpensesExcelComponent implements OnInit {

  isReload: boolean;
  expenseList: any[] = [];
  
  constructor(@Inject(MAT_DIALOG_DATA) public data: any,
    private user: UserServiceService, private dialogRef: MatDialogRef<ExpensesExcelComponent>) {
  }

  ngOnInit(): void {
    this.fetchExpence();
  }

  fetchExpence(): void {
    this.user.getExpenses(this.data.expense, this.data.startDate, this.data.endDate).subscribe((data: any[]) => {
    this.expenseList = data.map(item => ({
      date: item.date,
      expenses: item.expenses,
      price: item.price
    }));
    });

  }


  printTable() {
    const printContent = document.getElementById('ExpenseTable')?.outerHTML;
    const originalContent = document.body.innerHTML;

    document.body.innerHTML = printContent ?? '';
    window.print();
    document.body.innerHTML = originalContent;
    window.location.reload(); // To reload the page and reset the original content
  }

  exportToExcel() {
    // Convert HTML table to workbook
    const ws: XLSX.WorkSheet = XLSX.utils.table_to_sheet(document.getElementById('ExpenseTable')!);
    const wb: XLSX.WorkBook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');

    // Save the workbook
    XLSX.writeFile(wb, 'Expense_Data.xlsx');
  }

  cancel() {
    this.dialogRef.close({ 'isReload': this.isReload });
  }

}



<div class="button-group">
    <button mat-raised-button  (click)="exportToExcel()">
      <mat-icon>file_download</mat-icon>
      Export to Excel
    </button>
    <button mat-raised-button  (click)="printTable()">
      <mat-icon>picture_as_pdf</mat-icon>
      PDF
    </button>
    <button mat-raised-button  (click)="cancel()">
      <mat-icon>cancel</mat-icon>
      Cancel
    </button>
  </div>

<p>Expense Name : -{{data.expense}}</p>
<table id="ExpenseTable">
    <thead>
      <tr>
        <th scope="col">Date</th>
        <th scope="col">Expense</th>
        <th scope="col">Total</th>
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let item of expenseList">
        <td>{{ item.date }}</td>
        <td>{{ item.expenses }}</td>
        <td>{{ item.price }}</td>
      </tr>
    </tbody>
  </table>
  
  
  
  .button-group {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-bottom: 15px;
  }
  
  .button-group button {
    width: 140px;
  }
  

table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 16px;
    text-align: left;
}

th, td {
    padding: 12px 15px;
    border: 1px solid #ddd;
}

th {
    background-color: #f4f4f4;
    font-weight: bold;
}

tr:nth-child(even) {
    background-color: #f9f9f9;
}

tr:hover {
    background-color: #f1f1f1;
}

strong {
    font-weight: bold;
}

td[colspan="2"] {
    text-align: center;
}

table tr:last-child td {
    border-bottom: 2px solid #ddd;
}

.table-header {
    background-color: #4CAF50;
    color: white;
}

.total-row {
    background-color: #f2f2f2;
    font-weight: bold;
}

.total-amount-row {
    background-color: #e2e2e2;
    font-weight: bold;
}


getExpenses(
    expense: string,
    startDate: string,
    endDate: string
  ): Observable<any[]> {
    const userId = localStorage.getItem("userId");
    let params = new HttpParams()
      .set("expense", expense)
      .set("startDate", startDate)
      .set("endDate", endDate)
      .set("userId", userId);

    return this.http.get<any[]>(API_EXPENSE_EXCEL, { params });
  }
  
  export const API_EXPENSE_EXCEL: string = `${prefix}/portal/api/expensesExcel`;
  
  
   @GetMapping("/expensesExcel")
    public List<kharch> getExpenses(
            @RequestParam("startDate") String startDate,
            @RequestParam("endDate") String endDate,
            @RequestParam("expense") String expense,
            @RequestParam("userId") String userId) {
        return kharchrepository.findByDateBetweenAndExpensesLikeAndUserId(startDate, endDate, expense, userId);
    }
	
	  @Query("SELECT j FROM kharch j WHERE j.date BETWEEN :startDate AND :endDate AND j.expenses LIKE :expenses AND j.userId = :userId")
    List<kharch> findByDateBetweenAndExpensesLikeAndUserId(
            @Param("startDate") String startDate,
            @Param("endDate") String endDate,
            @Param("expenses") String expense,
            @Param("userId") String userId
    );
	
	
	
	
	////////////////////////////////////////////////////
	getTotalPetrolSell(): number {
    return this.PetrolSelltList.reduce((total, product) => 
      total + (parseFloat(product.total_sell) || 0), 0
    );
  }
  
  <td style="background-color: #d0b6b6;"><strong>{{ getTotalDiesel() | number:'1.2-2' }}</strong></td>
   getTotalDiesel(): number {
      return this.DieselSelltList.reduce((sum, product) => 
        sum + (parseFloat(product.total_sell) || 0), 0
      );
  }
  
  
    getTotalOilSell(): number {
      return this.OilsellList.reduce((total, product) => 
        total + (parseFloat(product.price) || 0), 0
      );
  }
  
  getKharch(): number {
      return this.kharchlist.reduce((total, product) => 
        total + (parseFloat(product.price) || 0), 0
      );
  }
  
   getTransaction(): number {
      return this.transaction.reduce((total, product) => 
        total + (parseFloat(product.amount) || 0), 0
      );
  }
  
  //////////////////////////////////////////////////////////////////////////////
   <div class="card">
               <div>
                  <canvasjs-chart [options]="chartOptions2" [styles]="{width: '100%', height:'360px'}"></canvasjs-chart>    
              </div>                        
            </div>
			
			chartOptions2: any = {
    animationEnabled: true,
    title: {
      text: "Fuel & Baki Distribution"
    },
    data: [{
      type: "pie",
      startAngle: 240,
      // yValueFormatString: "##0.00\"%\"",
      indexLabel: "{label} - {y}%",
      dataPoints: []
    }]
  };
  
  updatePieChart() {
    this.chartOptions2 = {
      ...this.chartOptions2,
      data: [{
        type: "pie",
        startAngle: 240,
        // yValueFormatString: "##0.00\"%\"",
        indexLabel: "{label} - {y}",
        dataPoints: [
          { y: this.petrollabel, label: "Petrol ($)" },
          { y: this.diesellabel, label: "Diesel ($)" },
          { y: this.jamabakilabel, label: "Baki ($)" }
        ]
      }]
    };
  }
  CanvasJSAngularChartsModule
  import { CanvasJSAngularChartsModule } from '@canvasjs/angular-charts';
  
  
  
getPurchaselist(){
  const formattedDate = this.use.getFormattedDate(this.reportDate);
  this.use.getPurchaseiList(formattedDate, this.userId).subscribe(
    (data) => {
      if (data && data.length > 0) {
        for (const item of data) {
          const [quantity, type] = item;
          if (type === 'Petrol') {
            this.petolQuantity = quantity;
          } else if (type === 'Diesel') {
            this.dieselQuantity = quantity;
          }
        }
      } else {
        this.petolQuantity = 0;
        this.dieselQuantity = 0;
      }      
    },
    (error) => {
      this.notificationService.failure("Failed to fetch Purchase data.");
    }
  );
}

    @Query("SELECT t1.Quantity,t1.type FROM Purchase t1 WHERE t1.date = :date AND t1.userId = :userId")
    List<Purchase> getPurchase(@Param("date") String date, @Param("userId") String userId);
